# WORK4 Вариант 11
# Генерация всех перестановок строки


Репозиторий содержит рекурсивные реализации генерации всех перестановок строки на Python, Java и C++.

---

## Python

### Как работает алгоритм:

- **Объявление функции** с параметром `s` (строка)
- `if len(s) <= 1:` — **базовый случай**, возвращает `[s]` если строка пустая или содержит один символ
- `for i, char in enumerate(s):` — перебираем каждый символ в строке
- `remaining = s[:i] + s[i+1:]` — формируем строку без текущего символа
- `for perm in generate_permutations(remaining):` — **рекурсивно генерируем перестановки** оставшейся строки
- `result.append(char + perm)` — добавляем текущий символ к каждой перестановке

### Временная сложность: **O(n!)**

**Почему такая сложность:**
Алгоритм генерирует все возможные перестановки строки, количество которых равно факториалу длины строки (n!). На каждом шаге рекурсии выполняется n вызовов для строки длины n-1.

---

## Java

### Как работает алгоритм:

- **Объявление метода** с параметром `s` (строка)
- `if (s.length() <= 1)` — **базовый случай**, возвращает список с одной строкой
- `for (int i = 0; i < s.length(); i++)` — перебираем каждый символ по индексу
- `char currentChar = s.charAt(i)` — получаем текущий символ
- `String remaining = s.substring(0, i) + s.substring(i + 1)` — формируем строку без текущего символа
- `for (String perm : generatePermutations(remaining))` — **рекурсивно генерируем перестановки** оставшейся строки
- `result.add(currentChar + perm)` — добавляем текущий символ к каждой перестановке

### Временная сложность: **O(n!)**

**Почему такая сложность:**
Как и в Python версии, алгоритм экспоненциально растет с увеличением длины строки, поскольку количество перестановок равно n!.

---

## C++

### Как работает алгоритм:

- **Объявление функции** с параметром `s` (строка)
- `if (s.length() <= 1)` — **базовый случай**, возвращает вектор с одной строкой
- `for (size_t i = 0; i < s.length(); ++i)` — перебираем каждый символ по индексу
- `char currentChar = s[i]` — получаем текущий символ
- `string remaining = s.substr(0, i) + s.substr(i + 1)` — формируем строку без текущего символа
- `vector<string> permutations = generatePermutations(remaining)` — **рекурсивно генерируем перестановки** оставшейся строки
- `result.push_back(currentChar + perm)` — добавляем текущий символ к каждой перестановке

### Временная сложность: **O(n!)**

**Почему такая сложность:**
Сложность определяется количеством генерируемых перестановок, которое растет факториально с увеличением длины входной строки.

---

### Вопрос №9 
# Чем отличаются перестановки от сочетаний?

### Перестановки:
- **Упорядоченные** arrangements элементов
- **Порядок следования имеет значение**
- Количество перестановок: **n!** (факториал n)
- Пример: `abc`, `acb`, `bac`, `bca`, `cab`, `cba` — разные объекты

### Сочетания:
- **Неупорядоченные** выборки элементов
- **Порядок не имеет значения**, важен только состав
- Количество сочетаний: **C(n,k) = n!/(k!(n-k)!)**
- Пример: `{a,b,c}` — один набор независимо от порядка

### Ключевое отличие:
В **перестановках** порядок элементов важен, в **сочетаниях** — нет.

Эти алгоритмы создают перестановки - они генерируют все возможные способы расстановки символов в разном порядке.
Для сочетаний нужен был бы другой алгоритм - он бы выбирал группы символов определенного размера, но не учитывал бы их порядок внутри группы. Например, комбинации "AB" и "BA" считались бы одинаковыми.
